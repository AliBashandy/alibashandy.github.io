---
title: "World's Statictics 2023 <br> Exploratory Data Analysis (EDA)"
author: "Ali Bashandy"
output:
  ioslides_presentation:
    widescreen: yes
    css: style.css
subtitle: World Map In Robinson Projection Based on R Maps<br>https://pjbartlein.github.io/REarthSysSci/RMaps.html<br>The full R code saved separetly in "Create World Map.R" file
---    


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r eval=FALSE, include=FALSE}
install.packages("tidyverse")
install.packages("ggplot2")
install.packages("gridExtra")
install.packages("reshape2")
install.packages("ggh4x")
install.packages("scales")
install.packages("ggpubr")
install.packages("here")
install.packages("visdat")
install.packages("extrafont")
install.packages("rgl")
install.packages("formattable") #format numeric as currency
install.packages("skimr")
```

```{r include=FALSE}
library(tidyverse) # essential ***
library(rgdal) #OgrListlayers
library(ggplot2) #plotting ***
library(ggspatial) #Spatial Layer***
library(extrafont) #for font Rstudio***
loadfonts(device = "win", quiet = TRUE) #***
library(readr) #Read CSV ***
library(gridExtra) # Table themes ***
library(skimr)
library(gtable) # Table grouping ***
library(grid) #Grid customization ***
library(scales) # Table text wrap ***
library(ggh4x) # Table panel size ***
library(ggrepel) # pop World map label repel
library(formattable) # Convert numeric to currency
library(treemapify) # for the treemap
library(sf)
library(leaflet)
#library(dplyr)
#library(RColorBrewer)
#library(reshape2)
#library(ggpubr)
#library(dplyr)
#library(here)
#library(crayon)
```

#  Introduction
This analysis based on Global Country Information Data set 2023 by Nidula Elgiriyewithana found in kaggle with public licence Attribution 4.0 International (CC BY 4.0). This comprehensive data set provides a wealth of information about all countries worldwide, covering a wide range of indicators and attributes. It encompasses demographic statistics, economic indicators, environmental factors, healthcare metrics, education statistics, and much more. With every country represented, this data set offers a complete global perspective on various aspects of nations, enabling in-depth analyses and cross-country comparisons.

# The Question?

Analyze the information about all countries worldwide then categorize them to top 10 and bottom 10. Use the information to get insight about correlation of different indicators and attributes through visualization.

# 1. Data Processing.

I have noticed that some values are not available for some countries but i decided to not drop countries with null values instead i will gather them in separate table during analysis

## 1.1. Data cleaning and verification:
<br>
1- Changed the name of Country "Sao Tome and Principe". It was added with unreadable characters.<br>
<br>
2- Changed the name of column "Density (P/Km2)" to remove the line break between "Density" and "(P/Km2).<br>
<br>

### The dataset summary:
<br>
```{r load dataset, echo=FALSE, fig.align="left", fig.height=1, fig.width=1, message=FALSE, warning=FALSE}
dataset <- read_csv("world-data-2023.csv")
colnames(dataset)[2] = "Density (P/Km2)"
dataset[dataset == "S�����������"]<- "Sao Tome and Principe"
skim(dataset)%>%
  summary()%>%
  print()

```
## 1.2. Creating Customized theme for Tables and output Messages.
<br>
<br>

### Setting Customized output message in case of no missing data in the column

<br>

```{r echo=TRUE, message=FALSE, warning=FALSE}
result_missing_data<- ggplot()+
  geom_rect(aes(xmin=0, xmax=2, ymin=0, ymax=0.5),
              color='darkgreen',
              fill = 'lightgreen', 
              alpha = 0.5) +
  geom_text(x=1,
              y=0.25,
              aes(label=c("Good News!!! No Missing Data")),
              size = 12,
              family="serif",
              color="darkgreen") +
  theme_void()
```
--------------------------------------------------------------

### Here are the code chunk for Setting customized table theme.
<br>
```{r echo=TRUE}
tt1 <- ttheme_default(core=list( bg_params = list(fill = "#D9E1F2"[2:1], 
                                                  col="white",
                                                  alpha = 0.75),
                                 fg_params=list(col = "black",
                                                fontface="bold",
                                                fontsize=10,
                                                fontfamily="serif")),
                      colhead=list(bg_params = list(fill = "#4472C4", 
                                                    col = "white",
                                                    alpha = 0.75), 
                                   fg_params=list(col = "white",
                                                  fontface= "bold",
                                                  fontsize=14,
                                                  fontfamily="serif"))
                        )
```

# 3. Analysis and Visualization

In this phase i will conduct the following steps to gain insights for top 10 and bottom 10 countries based on population density in km2, number of population, birth rate correlation with fertility rate, and gross domestic product (GDP) :
<br>
<br>
1- I will check the dataset for missing information.<br>
2- I will extract the lowest 10 and highest 10 countries based on the previously mentioned indicators and attributes.<br>
3- A variety of visualization methods will be used to visualize the results.

## 3.1 Density (P/Km2)
<br>
The code in this step will check the density column for missing values. If there are countries with missing values, the result will be a table with those countries. If nothing missing, an output message will pop up confirming that nothing is missing.
<br>
<br>

### The result of missing data checker is:
<br>
```{r echo=FALSE, fig.align="left", fig.height=0.5, fig.width=9, message=FALSE, warning=FALSE, paged.print=FALSE}
check_desnsity<- dataset%>%
  select(Country, `Density (P/Km2)`)%>%
  filter(is.na(`Density (P/Km2)`))%>%
  mutate(`Density (P/Km2)` = replace_na(0))

if (0 %in% check_desnsity$`Density (P/Km2)`||
    isTRUE(check_desnsity$`Density (P/Km2)`)
    )
  {
  tc0<- tableGrob(check_desnsity,
                  rows = NULL,
                  theme = tt1,
                  cols = (c("Countries with missing values","Density (P/Km2)"))
                  )
  tc0<- gtable_add_grob(tc0,
                        grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                        t = 1,
                        b = nrow(tc1),
                        l = 1,
                        r = ncol(tc1)
                        )
  tc0<- gtable_add_grob(tc0,
                        grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                        t = 1,
                        b=1,
                        l = 1,
                        r = ncol(tc1)
                        )
  grid.arrange(tc1, ncol = 2, nrow = 1)
  
  }else {
    
    result_missing_data
}

```

## 3.1.1 Top 10 countries with the highest Density(P/Km2).
<br>
The graph illustrated that Monaco has the highest density by 26,337 P/Km2.

```{r echo=FALSE, fig.align="left", fig.height=5, fig.width=10, message=FALSE, warning=FALSE, background=NULL}

# Filtering top 10 Countries with the highest density/Km2.

top_density<- dataset %>% 
  select(Country, `Density (P/Km2)`)%>%
  arrange(desc(`Density (P/Km2)`)) %>%
  slice(1:10)

# Customizing table borders.

t1<- tableGrob(top_density, rows = NULL, theme = tt1)
t1<- gtable_add_grob(t1,
                     grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 1)),
                     t = 1, b = nrow(t1), l = 1, r = ncol(t1))
t1 <- gtable_add_grob(t1,
                      grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 1)),
                      t = 1, b=1, l = 1, r = ncol(t1))

# Plotting Tables and bar charts.

# Plotting bar chart of top 10 countries.

p1<- ggplot(top_density, aes(x = `Density (P/Km2)`,
                             y = reorder(Country, +`Density (P/Km2)`),
                             fill=`Density (P/Km2)`)
            ) + 
  geom_bar(stat = "identity") +
  xlim(0,29000) + 
  ylab('Country Name') +
  xlab('Density (P/Km2)') +
  scale_y_discrete(labels = label_wrap(10),
                   guide = guide_axis(n.dodge=2)
                   ) +
  geom_text(aes(label = `Density (P/Km2)`),
            colour = "black",
            hjust= -0.2
            ) +
  force_panelsizes(rows = unit(4, "in"),
                   cols = unit(4, "in")
                   ) +
  #labs(title="Top 10 Countries with the highest density") +
  theme_void() +
  theme(panel.border = element_rect(fill= "transparent", size=1),
        panel.background = element_rect(fill = "transparent"),
        plot.title = element_text(hjust = 3,
                                  vjust = 2,
                                  size=16,
                                  face = "bold",
                                  family = "serif",
                                  color = "#01014B"),
        legend.position = "none",
        axis.title = element_blank(),
         # element_text(size=12,
          #                        face = "bold",
           #                       family = "serif",
            #                      color = "#01014B"),
        axis.text = element_text(size=10,
                                  family = "serif",
                                  color = "black")
        )

# Displaying the tables and the bar charts.
grid.arrange(t1,p1, ncol = 2, nrow = 1, widths = c(5,9))
          
```


## 3.1.2 Bottom 10 countries with the lowest Density(P/Km2).
<br>
The graph illustrated that Mongolia has the lowesdt density by only 2 P/Km2.

```{r echo=FALSE, fig.align="left", fig.height=5, fig.width=10, message=FALSE, warning=FALSE, background=NULL}

# Filtering bottom 10 countries with the lowest density/Km2.

bottom_density<- dataset %>%
  select(Country, `Density (P/Km2)`)%>%
  arrange((`Density (P/Km2)`))%>%
  slice(1:10)

# Customizing table borders.

t2<- tableGrob(bottom_density, rows = NULL, theme = tt1)
t2<- gtable_add_grob(t2,
                     grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 1)),
                     t = 1,
                     b = nrow(t2),
                     l = 1,
                     r = ncol(t2)
                     )
t2 <- gtable_add_grob(t2,
                      grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 1)),
                      t = 1,
                      b=1,
                      l = 1,
                      r = ncol(t2)
                      )


# Plotting bar chart of bottom 10 countries.

p2<- ggplot(bottom_density, aes(x = `Density (P/Km2)`, y = reorder(Country, +`Density (P/Km2)`), fill=`Density (P/Km2)`)) + 
  geom_bar(stat = "identity") +
  xlim(0,6) +
  ylab('Country Name') +
  xlab('Density (P/Km2)') +
  scale_y_discrete(labels = label_wrap(10),
                   guide = guide_axis(n.dodge=2)
                   ) +
  geom_text(aes(label = `Density (P/Km2)`),
            colour = "black",
            hjust= -0.2
            ) +
  force_panelsizes(rows = unit(4, "in"),
                   cols = unit(4, "in")
                   ) +
  #labs(title="Bottom 10 Countries with the lowest density") +
  theme_void() +
  theme(panel.border = element_rect(fill= "transparent", size=1),
        panel.background = element_rect(fill = "transparent"),
        plot.title = element_text(hjust = 3,
                                  vjust = 2,
                                  size=16,
                                  face = "bold",
                                  family = "serif",
                                  color = "#01014B"),
        legend.position = "none",
        axis.title =element_blank() ,
         # element_text(size=12,
          #                        face = "bold",
           #                       family = "serif",
            #                      color = "#01014B"),
        axis.text = element_text(size=10,
                                  family = "serif",
                                  color = "black")
        )

# Displaying the tables and the bar charts.

grid.arrange(t2,p2, ncol = 2, nrow = 1, widths = c(5,9))
```


## 3.2 World Population
<br>
In this phase i will conduct the following steps to gain insights for top 10 and bottom 10 countries based on population:
<br>
1- I will check the dataset for missing population information.

2- I will extract the lowest 10 and highest 10 countries based on population.

3- A population map will be used to visualize the results highlighting the highest and lowest 10 countries based on their population.
<br>

### The result of missing data checker is:
<br>
<p style="color:red;"> The population information of Palestine is missing from the data set. </p>

```{r echo=FALSE, fig.align="left", fig.height=1, fig.width=9, message=FALSE, warning=FALSE, paged.print=FALSE, background=NULL}
# Check for NA Population values.

check_population<- dataset %>%
  select(Country, Population)%>% 
  filter(is.na(Population))%>%
  mutate(Population = replace_na(0) )
if (0 %in% check_population$Population||isTRUE(check_population$Population)) {
  tc1<- tableGrob(check_population, rows = NULL, theme = tt1, cols = (c("Countries with missing values","Population")))
  tc1<- gtable_add_grob(tc1,
                     grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                     t = 1, b = nrow(tc1), l = 1, r = ncol(tc1))
  tc1<- gtable_add_grob(tc1,
                      grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                      t = 1, b=1, l = 1, r = ncol(tc1))
  grid.arrange(tc1, ncol = 2, nrow = 1,  widths = c(6,6))
  }else {
    result_missing_data
      }
```

## 3.2.1 Sorting countries by population and filtering highest and lowest 10
<br>
The tables shows that China has the highest population by 1.399 billions , meanwhile Vatican City has the lowest population by only 836.

```{r echo=FALSE, fig.align="left", fig.height=5, fig.width=10, message=FALSE, warning=FALSE, background=NULL}
pop<- dataset %>% 
  select (Country, Population, Longitude, Latitude)
# selecting top 10 countries by population
top_pop<- slice_max(pop, Population, n = 10)

# Selecting lowest 10 countries by population  
bottom_pop<- slice_min(pop, Population, n = 10)

# Setting up Tables
t3<- tableGrob(top_pop, 
               rows = NULL, 
               theme = tt1, 
               cols = (c("Top10 Countries","Population","Longitude","Latitude")
                       )
               )
t3<- gtable_add_grob(t3,
                     grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                     t = 1, b = nrow(t3), l = 1, r = ncol(t3))
t3 <- gtable_add_grob(t3,
                      grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                      t = 1, b=1, l = 1, r = ncol(t3))

t4<- tableGrob(bottom_pop, 
               rows = NULL, 
               theme = tt1, 
               cols = (c("Bottom10 Countries","Population","Longitude","Latitude")
                       )
               )
t4<- gtable_add_grob(t4,
                     grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                     t = 1, 
                     b = nrow(t4), 
                     l = 1, 
                     r = ncol(t4)
                     )
t4 <- gtable_add_grob(t4,
                      grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                      t = 1, 
                      b=1, 
                      l = 1, 
                      r = ncol(t4)
                      )
#Plotting table
grid.arrange(t3,t4, ncol = 2, nrow = 1, widths = c(8,9))

```


## 3.2.2 World Population map, highlighing Top 10 and Bottom 10.
<br>
The graphs shows the top 10 countries with the highest and the bottom 10 with the lowest population over the world map.

```{r echo=FALSE, fig.align="left", fig.height=5.5, fig.width=10, message=FALSE, warning=FALSE, background=NULL}
#Preparing data for plotting Population map.

tb_pop<- rbind(top_pop,bottom_pop)%>% #merging both tables into one
arrange(desc(Population)) # arranging by population descending order

#Tuvalu coordinates are missing from World_map, downloaded from https://github.com/Thom-J-H/map_Gap_2_Tidy/blob/main/tuvalu_coords.rds
tuvalu_coords <- readRDS("D:/Github/Data Analysis Projects/Global EDA_Visualization in R/tuvalu_coords.rds")
colnames(tuvalu_coords)[5] = "Country"

#Customizing world map data to match our dataset
world_map <- map_data("world")%>%
  select(long, lat, group, order, region)
  colnames(world_map)[5] = "Country"   #changing column name from region to country to match the data set
  
  world_map<- world_map%>%
  mutate(Country = recode(Country, `USA` = "United States",
                          `Bahamas` = "The Bahamas",
                          `Republic of Congo` = "Republic of the Congo",
                          `Gambia` = "The Gambia",
                          `UK` = "United Kingdom",
                          `Trinidad` = "Trinidad and Tobago",
                          `Tobago` = "Trinidad and Tobago",
                          `Vatican` = "Vatican City",
                          `Ireland` = "Republic of Ireland",
                          `Micronesia` = "Federated States of Micronesia",
                          `Palestine` = "Palestinian National Authority",
                          `Swaziland` = "Eswatini",
                          `Timor-Leste` = "East Timor",
                          `Antigua` = "Antigua and Barbuda",
                          `Barbuda` = "Antigua and Barbuda",
                          `Saint Kitts` = "Saint Kitts and Nevis",
                          `Nevis` = "Saint Kitts and Nevis",
                          `Saint Vincent` = "Saint Vincent and the Grenadines",
                          `Grenadines` = "Saint Vincent and the Grenadines"
                                 )
                   )  
  
#adding Tuvalu coordinates to world map
world_map_complete<- rbind(world_map,tuvalu_coords) #merging both tables into one


# Check if there is any country is available at the data set and not available at the world map
world_map_check<- world_map_complete%>%
  distinct(Country)
dataset_check<- dataset%>%
  select(Country)
result1<- anti_join(dataset_check, world_map_check, by = c("Country"))


# Joining World map dataset with Population dataset.
pop_map<- left_join(world_map_complete, pop, by = "Country")
pop_map[is.na(pop_map)] <- 0

# Plot World Population map.
ggplot() +
  geom_polygon(data = pop_map,
               aes(x = long, y =lat, group = group, fill = Population),
               color = "white"
               ) +
  scale_fill_gradientn(
    values = scales::rescale(c(0,10000,100000,1000000,10000000,100000000,500000000,1397715000)),
    breaks = c(0,10000,100000,1000000,10000000,100000000,500000000,1397715000),
    labels = c("No Data","< 10,000","< 100,000","< 1,000,000",
               "< 10,000,000","< 100,000,000","< 500,000,000","</= 1,397,715,000"),
    colours = blues9,
                      ) +
  guides(fill = guide_legend(reverse = T)) + 
  labs(fill = 'Population',
       #title = 'World Population',
       #subtitle = 'Population by Country 2023',
       x = NULL,
       y = NULL
       ) +
  theme_bw()+
  theme(text = element_text(color = '#01014B'),
        plot.title = element_text(size = 12,  family = "serif"),
        plot.subtitle = element_text(size = 10, family = "serif"),
        axis.ticks = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_line(color = "white"),
        panel.background = element_rect(fill = '#D9E1F2'),
        plot.background = element_rect(fill = 'white'),
        legend.position = c(.1,.36),
        legend.background = element_blank(),
        legend.key = element_rect(color = 'black'),
        legend.key.size = unit(0.5,'cm'),
        legend.text = element_text(size=9, family = "serif"),
        legend.title = element_text(size = 10,
                                    family = "serif",
                                    face = "bold"
                                   ),
        ) +
  geom_point(data = top_pop,
             aes (x = Longitude, y = Latitude, color = "Top 10"),
             size = 2
             ) +
  geom_label_repel(data = top_pop,
                   aes(x = Longitude, y = Latitude, label = Country),
                   box.padding   = 0.25, 
                   point.padding = 0.5,
                   segment.color = 'black',
                   color = 'red',
                   position = position_dodge(width = 0)
                   ) +
  geom_point(data = bottom_pop,
             aes (x = Longitude, y = Latitude, color = "Bottom 10"),
             size = 2
             ) +
  geom_label_repel(data = bottom_pop,
                   aes(x = Longitude, y = Latitude, label = Country),
                   box.padding   = 0.25,
                   point.padding = 0.5,
                   segment.color = 'black',
                   color = 'darkgreen',
                   position = position_dodge(width = 0)
                   ) +
  scale_colour_manual(name="Category Top/Bottom", values = c("Top 10"="red","Bottom 10"="darkgreen"))
```


## 3.3 Birth rate correlation with Fertility rate.
<br>
In this phase i will conduct the following steps to gain insights about the correlation between birth rate and fertility rate. Also, filtering the highest and lowest 10 countries based on both factors the result will be consolidated in two tables one for each factor:
<br>
1- I will check the data set for missing information.

2- I will extract the lowest 10 and highest 10 countries based on birth rate "and" fertility rate.

3- A line chart will be used to visualize the results highlighting the highest and lowest countries based on both factors.
<br>

### The result of missing data checker is:

<br>
<p style="color:red;"> The table below shows the countries if either the fertility rate or the birth rate are missing from the dataset </p>
```{r echo=FALSE, fig.align = "left", fig.height=2.2, fig.width=5, message=FALSE, warning=FALSE, paged.print=FALSE, background=NULL}
# Check for NA values.

check_bfrate<- dataset%>%
  select(Country, `Fertility Rate`, `Birth Rate`)%>%
  filter_at(vars(`Fertility Rate`,`Birth Rate`),any_vars(is.na(.)))%>%
  mutate(`Fertility Rate`= coalesce(`Fertility Rate`, 0),
         `Birth Rate` = coalesce(`Birth Rate`, 0))

if (0 %in% check_bfrate$`Fertility Rate`||
    isTRUE(check_bfrate$`Fertility Rate`||
           0 %in% check_bfrate$`Birth Rate`||
           isTRUE(check_bfrate$`Birth Rate` )
           )
    ) 
  {
  tc2<- tableGrob(check_bfrate,rows = NULL,
                  theme = tt1, 
                  cols = (c("Countries with missing values","Fertility Rate","Birth Rate")
                          )
                  )
  tc2<- gtable_add_grob(tc2,
                        grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                        t = 1,
                        b = nrow(tc2),
                        l = 1,
                        r = ncol(tc2)
                        )
  tc2<- gtable_add_grob(tc2,
                        grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                        t = 1,
                        b=1,
                        l = 1,
                        r = ncol(tc2)
                        )
  grid.arrange(tc2, ncol = 2, nrow = 1, widths = c(6,0))
  
  }else {
    result_missing_data
      }
```

## 3.3.1 Categorizing highest and lowest 10 by Birth rate and Fertility rate.
<br>
In this step the 10 highest and the 10 lowest countries by birth rate and fertility rate got filtered then merged both tables to get more in depth insights about the correlation between the two attributes. That is the reason why there are more than 10 countries in each table. 

```{r echo=FALSE, fig.align="left", fig.height=4, fig.width=10, message=FALSE, warning=FALSE, background=NULL}
bf_rate<- dataset %>% 
  select (Country, `Fertility Rate`, `Birth Rate`)%>%
  drop_na()

# selecting top 10 countries by Birth Rate then by fertility rate and merge the data.
top_birthrate<- slice_max(bf_rate, `Birth Rate`, n = 10)
top_fertilityrate<- slice_max(bf_rate, `Fertility Rate`, n=10)
top_fbrate <- merge(top_birthrate, top_fertilityrate, all.x=TRUE, all.y=TRUE) 

# selecting bottom 10 countries by Birth Rate then by fertility rate and merge the data.
bottom_birthrate<- slice_min(bf_rate, `Birth Rate`, n = 10)
bottom_fertilityrate<- slice_min(bf_rate, `Fertility Rate`, n=10)
bottom_fbrate <- merge(bottom_birthrate, bottom_fertilityrate, all.x=TRUE, all.y=TRUE) 

# Setting up Tables
t5<- tableGrob(top_fbrate,
               rows = NULL,
               theme = tt1,
               cols = (c("Top Countries","Fertility Rate","Birth Rate")
                       )
               )
t5<- gtable_add_grob(t5,
                     grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                     t = 1,
                     b = nrow(t5),
                     l = 1,
                     r = ncol(t5)
                     )
t5 <- gtable_add_grob(t5,
                      grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                      t = 1,
                      b=1,
                      l = 1,
                      r = ncol(t5)
                      )

t6<- tableGrob(bottom_fbrate,
               rows = NULL,
               theme = tt1,
               cols = (c("Bottom Countries","Fertility Rate","Birth Rate")
                       )
               )
t6<- gtable_add_grob(t6,
                     grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                     t = 1,
                     b = nrow(t6),
                     l = 1,
                     r = ncol(t6)
                     )
t6 <- gtable_add_grob(t6,
                      grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                      t = 1,
                      b=1,
                      l = 1,
                      r = ncol(t6)
                      )
#Plotting table
grid.arrange(t5,t6, ncol = 2, nrow = 1)

```

## 3.3.2 Correlation between Birth rate and Fertility rate columns highliting Top and Bottom Countires.
<br>
The graphs illustrated that Niger has the highest birth rate and fertility rate, meanwhile South Korea has the lowest. Also, there is direct and high correlation between fertility and birth rate. 

```{r echo=FALSE, fig.align="left", fig.height=5, fig.width=9, message=FALSE, warning=FALSE, background=NULL}
bf_coorelation <- dataset%>%
  select(Country, `Fertility Rate`, `Birth Rate`)%>%
  drop_na()

ggplot(bf_coorelation,
       aes(x=`Fertility Rate`, y=`Birth Rate`)
       ) +
  geom_jitter(color= "#4472C4",
              position=position_jitter(0.15),
              alpha=0.75,
              size=2
              ) +
  geom_point(data = top_fbrate,
             aes(x=`Fertility Rate`, 
                 y=`Birth Rate`, 
                 color='Top Countries'
                 ),
             size = 5
             ) +
  geom_point(data = bottom_fbrate,
             aes(x=`Fertility Rate`, 
                 y=`Birth Rate`, 
                 color='Bottom Countries'
                 ),
             size = 5
             ) +
  geom_smooth(color= "#01014B" ) +
  labs(title = NULL,
       x= "Fertility Rate",
       y="Birth Rate"
       ) +
  theme(panel.border = element_rect(fill=NA,
                                    color = "black",
                                    linewidth = 1),
        panel.background = element_rect(fill = "#D9E1F2"),
        plot.title = element_text(hjust = 0.5,
                                  size=20,
                                  face = "bold",
                                  color = "#01014B",
                                  family = 'serif'),
        axis.title.x=element_text(size=14,
                                  color = "#01014B",
                                  family = 'serif' ),
        axis.title.y=element_text(size=14,
                                  color = "#01014B",
                                  family = 'serif'),
        legend.key.size = unit(1,'cm'),
        legend.text = element_text(size = 12,
                                   family = "serif",
                                   color = "#01014B"),
        legend.title = element_text(size = 14,
                                    family = "serif",
                                    color = "#01014B",
                                    face = "bold"
                                   ),
        legend.position = c(.15,.85),
        legend.background = element_blank(),
        legend.key = element_rect(color = 'black')
        ) +
   scale_colour_manual(name="Category Top/Bottom",
                       values = c("Top Countries"="red","Bottom Countries"="darkgreen")
                       )
```


## 3.4 Gross Domestic Product (GDP)
<br>
In this phase i will conduct the following steps to gain insights about the Gross Domestic Product (GDP). Also, filtering the highest and lowest 10 countries based on GDP:
<br>
1- I will check the dataset for missing information.

2- I will extract the lowest 10 and highest 10 countries based on GDP.

3- Two treemap charts will be used to visualize the results highlighting the highest and lowest countires based on GDP.
<br>

### The result of missing data checker is:

<br>
<p style="color:red;"> The table shows the countries' GDP which are missing from the dataset </p>

```{r echo=FALSE, fig.align="left", fig.height=1, fig.width=9, message=FALSE, warning=FALSE, paged.print=FALSE, background=NULL}
# Check for NA Population values.


check_gdp<- dataset%>%
  select(Country, GDP)%>%
  filter(is.na(GDP))%>%
  mutate(GDP = replace_na(0))

if (0 %in% check_gdp$GDP||
    isTRUE(check_gdp$GDP)
    ) 
  {
  tc3<- tableGrob(check_gdp,
                  rows = NULL,
                  theme = tt1, 
                  cols = (c("Countries with missing values","GDP")
                          )
                  )
  tc3<- gtable_add_grob(tc3,
                        grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                        t = 1,
                        b = nrow(tc3),
                        l = 1,
                        r = ncol(tc3)
                        )
  tc3<- gtable_add_grob(tc3,
                        grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                        t = 1,
                        b=1,
                        l = 1,
                        r = ncol(tc3)
                        )
  grid.arrange(tc3, ncol = 2, nrow = 1, widths = c(5,9))
  
  }else {
    result_missing_data
      }
```

## 3.4.1 Sorting countries by GDP and filtering highest and lowest 10
<br>
The table illustrated the top 10 countries with the highest GDP, and the 10 bottom with the lowest GDP in millions USD.

```{r echo=FALSE, fig.align="left", fig.height=4, fig.width=10, message=FALSE, warning=FALSE, background=NULL}
data_gdp<- dataset %>% 
    select (Country, GDP)%>%
    mutate(GDP = gsub('[$,]','', GDP))%>% 
    mutate(GDP = as.numeric(GDP))%>%
    mutate(GDP = currency(GDP, digits = 0L))

# selecting top 10 countries by population
top_gdp<- slice_max(data_gdp, GDP, n = 10)

# Selecting lowest 10 countries by population  
bottom_gdp<- slice_min(data_gdp, GDP, n = 10)

# Setting up Tables
t7<- tableGrob(top_gdp, 
               rows = NULL,
               theme = tt1,
               cols = (c("Top 10 Countries","GDP")
                       )
               )
t7<- gtable_add_grob(t7,
                     grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                     t = 1,
                     b = nrow(t7),
                     l = 1,
                     r = ncol(t7)
                     )
t7 <- gtable_add_grob(t7,
                      grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                      t = 1,
                      b=1,
                      l = 1,
                      r = ncol(t7)
                      )

t8<- tableGrob(bottom_gdp, 
               rows = NULL,
               theme = tt1,
               cols = (c("Bottom 10 Countries","GDP")
                       )
               )
t8<- gtable_add_grob(t8,
                     grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                     t = 1,
                     b = nrow(t8),
                     l = 1,
                     r = ncol(t8)
                     )
t8 <- gtable_add_grob(t8,
                      grobs = rectGrob(gp = gpar(col = "black",fill = NA, lwd = 3)),
                      t = 1,
                      b=1,
                      l = 1,
                      r = ncol(t8)
                      )
#Plotting table
grid.arrange(t7,t8, ncol = 2, nrow = 1)


```

## 3.4.2 Treemaps visualizing the highest and lowest 10 countries based on GDP
<br>
The graphs illustrated that USA has the highest GDP 21,427,700 millions USD, meanwhile Tuvalu has the lowest GDP 47 millions USD

```{r echo=FALSE, fig.align="left", fig.height=5, fig.width=10, message=FALSE, warning=FALSE, background=NULL}
top_gdp_plot<- ggplot(top_gdp,
                      aes(area = GDP/1000000, fill = Country,
                          label = paste(Country, GDP/1000000,"mil USD", sep = "\n")
                          )
                      )+
  geom_treemap(alpha = 0.50,
               start = "topleft",
               radius = unit(15,"pt")
               )+
  geom_treemap_text(colour = "black",
                    place = "centre",
                    min.size = 6,
                    grow = FALSE,
                    reflow = TRUE,
                    start = "topleft"
                    )+
  labs(title = "The 10 Countries with highest GDP")+
  theme(legend.position = "none",
        plot.background = element_blank(),
        panel.background = element_blank(),
        plot.title = element_text(family = "serif",
                                  color = "#01014B",
                                  size = 14,
                                  hjust = 0.5)
        ) +
  scale_fill_manual(values = (c("United States"="lightgreen",
                              "China"="#e7e9f7", 
                              "Japan"="#ced4ef", 
                              "Germany"="#b5c0e6", 
                              "United Kingdom"="#9cabde",
                              "France"="#8298d5", 
                              "India"="#6585cd", 
                              "South Korea"="#4472c4", 
                              "Italy"="#28547a", 
                              "Brazil"="#023881")
                            )
                  )

bottom_gdp_plot<- ggplot(bottom_gdp,
                      aes(area = GDP/1000000, fill = Country,
                          label = paste(Country, GDP/1000000,"mil USD", sep = "\n")
                          )
                      )+
  geom_treemap(alpha = 0.50,
               start = "topleft",
               radius = unit(15,"pt")
               )+
  geom_treemap_text(colour = "black",
                    place = "centre",
                    family = "serif",
                    min.size = 6,
                    grow = FALSE,
                    reflow = TRUE,
                    start = "topleft"
                    )+
  labs(title = "The 10 Countries with lowest GDP ")+
  theme(legend.position = "none",
        plot.background = element_blank(),
        plot.title = element_text(family = "serif",
                                  color = "#01014B",
                                  size = 14,
                                  hjust = 0.5
                                  ),
        panel.background = element_blank()
        ) +
scale_fill_manual(values = (c("Tuvalu"="red",
                              "Nauru"="#e7e9f7", 
                              "Kiribati"="#ced4ef", 
                              "Marshall Islands"="#b5c0e6", 
                              "Palau"="#9cabde",
                              "Federated States of Micronesia"="#8298d5", 
                              "Sao Tome and Principe"="#6585cd", 
                              "Tonga"="#4472c4", 
                              "Dominica"="#28547a", 
                              "Saint Vincent and the Grenadines"="#023881")
                            )
                  )


grid.arrange(top_gdp_plot, bottom_gdp_plot,nrow = 1,heights = c(6), ncol = 2, widths = c(5,5))
```


## 4. Hover to know more
<br>
In this part i use world map with leaflet option to create an interactive world map. The map has some information about the countries such as Official name, Population, Density, land area, and GDP. All you have to do is to hover over the country.
The map has information for only the 195 countries included in the dataset.

```{r include=FALSE}
# Natural Earth shape files -- global (Robinson) projections
# get shapefiles from http://www.naturalearthdata.com

shape_path <- "D:/Github/Data Analysis Projects/Global EDA_Visualization in R/Natural Earth Shapes"
coastline_shapefile <- paste(shape_path, "/ne_50m_coastline.shp", sep="")
ocean_shapefile <- paste(shape_path, "/ne_50m_ocean.shp", sep="")
countries_shapefile <- paste(shape_path, "/ne_50m_admin_0_countries.shp", sep="")
boundingbox_shapefile <- paste(shape_path, "/ne_50m_wgs84_bounding_box.shp", sep="")
graticules30_shapefile <- paste(shape_path, "/ne_50m_graticules_30.shp", sep="")
rivers_shapefile <- paste(shape_path, "/ne_50m_rivers_lake_centerlines.shp", sep="")
lakes_shapefile <- paste(shape_path, "/ne_50m_lakes.shp", sep="")
snowareas_shapefile <- paste(shape_path, "/ne_50m_glaciated_areas.shp", sep="")

# read the shape file

layer <- ogrListLayers(coastline_shapefile) # find out kind of shapefile (lines vs. polygons)
ogrInfo(coastline_shapefile, layer=layer)
coast_lines <- readOGR(coastline_shapefile, layer=layer) # read the shape file

layer <- ogrListLayers(rivers_shapefile)
ogrInfo(rivers_shapefile, layer=layer)
rivers_lines <- readOGR(rivers_shapefile, layer=layer)

layer <- ogrListLayers(ocean_shapefile)
ogrInfo(ocean_shapefile, layer=layer)
ocean_poly <- readOGR(ocean_shapefile, layer=layer)

layer <- ogrListLayers(snowareas_shapefile)
ogrInfo(snowareas_shapefile, layer=layer)
snowareas_poly <- readOGR(snowareas_shapefile, layer=layer)

layer <- ogrListLayers(lakes_shapefile)
ogrInfo(lakes_shapefile, layer=layer)
lakes_poly <- readOGR(lakes_shapefile, layer=layer)

layer <- ogrListLayers(countries_shapefile)
ogrInfo(countries_shapefile, layer=layer)
countries_poly <- readOGR(countries_shapefile, layer=layer)

layer <- ogrListLayers(graticules30_shapefile)
ogrInfo(graticules30_shapefile, layer=layer)
graticules30_lines <- readOGR(graticules30_shapefile, layer=layer)

layer <- ogrListLayers(boundingbox_shapefile)
ogrInfo(boundingbox_shapefile, layer=layer)
boundingbox_poly <- readOGR(boundingbox_shapefile, layer=layer)

# set Robinson CRS
#unproj_crs <- CRS("+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0")

robin_crs <- CRS("+proj=robin +lon_0=0w")

# do projections
boundingbox_poly_proj <- spTransform(boundingbox_poly, robin_crs)
coast_lines_proj <- spTransform(coast_lines, robin_crs)
rivers_lines_proj <- spTransform(rivers_lines, robin_crs)
countries_poly_proj <- spTransform(countries_poly, robin_crs)
graticules30_lines_proj <- spTransform(graticules30_lines, robin_crs)
ocean_poly_proj <- spTransform(ocean_poly, robin_crs)
snowareas_poly_proj <- spTransform(snowareas_poly, robin_crs)
lakes_poly_proj <- spTransform(lakes_poly, robin_crs)
```


```{r echo=FALSE, fig.align="left", fig.height=5, fig.width=10, message=FALSE, warning=FALSE}
# preparing shapefile data to match the dataset
#in the below code iam changing the name of countries to match the dataset to facilitate the join function

countries_poly@data<- countries_poly@data%>%
  mutate(ADMIN = recode(ADMIN, `United States of America` = "United States",
                        `Cabo Verde` = "Cape Verde",
                        `Czechia` = "Czech Republic",
                        `Gambia` = "The Gambia",
                        `São Tomé and Principe` = "Sao Tome and Principe",
                        `Republic of Serbia` = "Serbia",
                        `United Republic of Tanzania` = "Tanzania",
                        `Vatican` = "Vatican City",
                        `Ireland` = "Republic of Ireland",
                        `Palestine` = "Palestinian National Authority",
                        `eSwatini` = "Eswatini"
                        )
         )  


countries_poly@data<- left_join(countries_poly@data, dataset, by=c('ADMIN'='Country'), keep=TRUE)

map_text<-paste("Country Name: ",countries_poly@data$FORMAL_EN,"<br/>",
                "Capital: ",countries_poly@data$`Capital/Major City`,"<br/>",
                "Official Language: ",countries_poly@data$`Official language`,"<br/>",
                "Population: ",comma(countries_poly@data$Population, digits = 0),"<br/>",
                "Density(P/Km2): ", countries_poly@data$`Density (P/Km2)`,"<br/>",
                "Land Area(Km2): ",comma(countries_poly@data$`Land Area(Km2)`, digits = 0),"<br/>",
                "Gross domestic product(GDP): ",countries_poly@data$GDP,"<br/>", 
                sep = "")%>%
  lapply(htmltools::HTML)


# Create a color palette with handmade bins.

map_bins <- c(0,10000,100000,1000000,10000000,100000000,500000000,1397715000)
map_palette <- colorBin( palette="Blues", domain=countries_poly@data$Population, na.color="transparent", bins=map_bins)

leaflet(countries_poly) %>% 
  addTiles()  %>% 
  setView( lat=30, lng=0 , zoom=1) %>%
  addPolygons(fillColor = ~map_palette(countries_poly@data$Population) , 
              stroke= FALSE,
              fillOpacity = 0.7,
              color = "white",
              opacity = 1,
              weight=2,
              dashArray = "3",
              label = map_text,
              labelOptions = labelOptions(
                style = list("font-weight" = "normal",padding = "3px 8px"),
                textsize = "12px",
                direction = "auto"
                )
             
  )
```


# The End <br><br>Thank you
